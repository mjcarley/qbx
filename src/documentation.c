/*
 * Autogenerated file, do not  edit
 * Mon Aug 17 10:43:26 BST 2020
 * -------------------------------
 */


/**
 * @ingroup location
 *
 * @brief Locate nearest point on an element
 *
 * Locate the nearest point on an element using the iterative
 * algorithm of Li X, Wu Z, Pan F et al. A geometric strategy
 * algorithm for orthogonal projection onto a parametric
 * surface. https://dx.doi.org/10.1007/s11390-019-1967-z
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param xf field point;
 * @param sn on exit reference element coordinate of nearest point;
 * @param tn on exit reference element coordinate of nearest point;
 * @param p1 physical location of nearest point;
 * @param tol tolerance for iteration;
 * @param nimax maximum number of iterations;
 * @param kn curvature at nearest point.
 *
 * @return number of iterations
 **/

gint qbx_element_nearest_point(gdouble *xe, gint xstr,
						  gint ne,
						  gdouble *xf, 
						  gdouble *sn, gdouble *tn, 
						  gdouble *p1, gdouble tol,
						  gint nimax, gdouble *kn) ;

/**
 * @ingroup quadrature
 *
 * @brief Integration of Laplace potential on triangular element, with
 * field point on element ("self term")
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s0 reference element coordinate of evaluation point;
 * @param t0 reference element coordinate of evaluation point;
 * @param in if TRUE, generate expansion on the negative side of the 
 * element, as determined by surface normal;
 * @param q quadrature rule nodes and weights;
 * @param nq number of entries in \a q;
 * @param oq order of \a q (highest order polynomial integrated exactly);
 * @param Nmax maximum order of expansion;
 * @param dmax maximum recursin depth in adaptive quadrature;
 * @param tol error tolerance;
 * @param Is on exit integrated single layer potential for nodal shape 
 * functions;
 * @param istr stride in \a Is (ignored for now);
 * @param Id on exit integrated double layer potential for nodal shape 
 * functions;
 * @param dstr stride in \a Id (ignored for now);
 * @param work workspace.
 *
 * @return 0 on success
 *
 **/

gint qbx_triangle_laplace_self_quad(gdouble *xe,
						       gint xstr,
						       gint ne,
						       gdouble s0,
						       gdouble t0,
						       gboolean in,
						       gdouble *q,
						       gint nq, gint oq,
						       gint Nmax, gint dmax,
						       gdouble tol,
						       gdouble *Is, gint istr,
						       gdouble *Id, gint dstr,
						       gdouble *work) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace single layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of nodes in \a q;
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param C on exit contains coefficients of expansion;
 * @param str data stride in \a C
 *
 * @return 0 on success.
 *
 **/

gint qbx_expansion_make_laplace_sl(gdouble *xe,
						      gint xstr, gint ne,
						      gdouble *fe,
						      gint fstr, gint nf,
						      gdouble *q, gint nq,
						      gdouble *xc,
						      gdouble rc, gint N,
						      gdouble *C, gint str) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace double layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of nodes in \a q;
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param C on exit contains coefficients of expansion;
 * @param str data stride in \a C
 *
 * @return 0 on success.
 *
 **/

gint qbx_expansion_make_laplace_dl(gdouble *xe,
						      gint xstr, gint ne,
						      gdouble *fe,
						      gint fstr, gint nf,
						      gdouble *q, gint nq,
						      gdouble *xc,
						      gdouble rc, gint N,
						      gdouble *C, gint str) ;

/**
 * @ingroup laplace
 *
 * @brief Evaluate a Laplace expansion
 *
 * @param xc centre of expansion;
 * @param N order of expansion;
 * @param C expansion coefficients;
 * @param str stride/number of elements in function evaluation;
 * @param x evaluation point;
 * @param f on exit contains expansion evaluated at \a x for \a str elements;
 * @param ee on exit contains last term added to \a f, as error estimator.
 *
 * @return 0 on success.
 * 
 **/

gint qbx_expansion_eval_laplace(gdouble *xc, gint N,
						   gdouble *C, gint str,
						   gdouble *x, gdouble *f,
						   gdouble *ee) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace double layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of entries in \a q;
 * @param order order of \a q (highest order polynomial integrated exactly);
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param L expansion coefficients;
 * @param str stride of entries in \a L;
 * @param depth maximum recursion depth;
 * @param tol quadrature tolerance (used in terminating recursion);
 * @param w element dimension;
 * @param init if TRUE, zero expansion entries before integrating;
 * @param single if TRUE, generate expansion for single-layer potential, 
 * otherwise for double-layer.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_expansion_make_laplace_adaptive(gdouble *xe,
							    gint xstr, gint ne,
							    gdouble *fe,
							    gint fstr, gint nf,
							    gdouble *q,
							    gint nq, gint order,
							    gdouble *xc,
							    gdouble rc, gint N,
							    gdouble *L,
							    gint str,
							    gint depth,
							    gdouble tol,
							    gdouble w,
							    gboolean init,
							    gboolean single) ;
/**
 * @ingroup base
 *
 * @brief Shape function evaluations for three-dimensional elements
 * 
 * On entry \a L may not be NULL, but if \a dLds is NULL, first and
 * second derivatives are not evaluated. If \a dLdss is NULL, first
 * derivatives are evaluated, but not second.
 * 
 * @param ne number of nodes on element (currently 3 or 6);
 * @param s coordinate on element;
 * @param t coordinate on element;
 * @param L on exit shape function evaluated at each node;
 * @param dLds on exit \f$\partial L_{i}/\partial s\f$ at each node;
 * @param dLdt on exit \f$\partial L_{i}/\partial t\f$ at each node;
 * @param dLdss on exit \f$\partial^{2} L_{i}/\partial s^{2}\f$ at each node;
 * @param dLdst on exit \f$\partial^{2} L_{i}/\partial s\partial t\f$ 
 * at each node;
 * @param dLdtt on exit \f$\partial^{2} L_{i}/\partial t^{2}\f$ at each node;
 *
 * @return 0 on success.
 * 
 **/

gint qbx_element_shape_3d(gint ne, gdouble s, gdouble t,
					     gdouble *L,
					     gdouble *dLds, gdouble *dLdt,
					     gdouble *dLdss, gdouble *dLdst,
					     gdouble *dLdtt) ;

/**
 * @ingroup base
 *
 * @brief Interpolation of point on element using shape functions
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param L shape function from ::qbx_element_shape_3d(...);
 * @param dLds derivative of shape function;
 * @param dLdt derivative of shape function;
 * @param y on exit interpolated point on element;
 * @param n on exit normal at \a y;
 * @param J on exit Jacobian at \a y;
 * @param c reserved for future use (can be NULL).
 * 
 * @return 0 on success.
 *
 **/

gint qbx_element_point_interp_3d(gdouble *xe,
						    gint xstr, gint ne,
						    gdouble *L,
						    gdouble *dLds,
						    gdouble *dLdt,
						    gdouble *y,
						    gdouble *n,
						    gdouble *J,
						    gdouble *c) ;


/**
 * @ingroup base
 *
 * @brief Convenience function for direct evaluation of point position
 * on element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s coordinate on element;
 * @param t coordinate on element;
 * @param y on exit interpolated point on element;
 * @param n on exit normal at \a y;
 * @param J on exit Jacobian at \a y;
 * @param c reserved for future use (can be NULL).
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_element_point_3d(gdouble *xe, gint xstr, gint ne,
					     gdouble s, gdouble t,
					     gdouble *y, gdouble *n,
					     gdouble *J, gdouble *c) ;

/**
 * @ingroup base
 *
 * @brief Quadrature error estimator
 *
 * Quadrature error estimator from Siegel and Tornberg, A local target
 * specific quadrature by expansion method for evaluation of layer
 * potentials in 3D, https://doi.org/10.1016/j.jcp.2018.03.006
 * 
 * @param N order of expansion term;
 * @param h element dimension;
 * @param order order of quadrature rule;
 * @param r distance from expansion centre;
 * @param rp distance to closest point on element;
 * 
 * @return estimate of error in integration of \f$N\f$th expansion term.
 * 
 **/

gdouble qbx_quadrature_error(gint N, gdouble h, gint order,
						 gdouble r, gdouble rp) ;



/**
 * @ingroup base
 *
 * @brief Estimate surface area of element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param qrule nodes and weights of quadrature rule;
 * @param nq number of nodes in \a qrule.
 * 
 * @return estimate of area of element.
 * 
 **/

gdouble qbx_element_area(gdouble *xe, gint xstr, gint ne,
					     gdouble *qrule, gint nq) ;



/**
 * @ingroup base
 *
 * @brief Truncation error estimator for triangular element
 * 
 * Truncation error estimator from Siegel and Tornberg, A local target
 * specific quadrature by expansion method for evaluation of layer
 * potentials in 3D, https://doi.org/10.1016/j.jcp.2018.03.006
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param qrule quadrature rule used to estimate element area (does not 
 * need to be high order);
 * @param nq number of nodes in \a qrule;
 * @param N order of expansion;
 * @param rc distance from expansion centre;
 * @param depth recursion depth for subdivision of element;
 * @param ee on exit contains error estimators for single- and
 * double-layer potential evalution.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_triangle_truncation_error(gdouble *xe,
						      gint xstr, gint ne,
						      gdouble *qrule, gint nq,
						      gint N,
						      gdouble rc, gint depth,
						      gdouble *ee) ;



/**
 * @ingroup base
 *
 * @brief Estimate parameters for optimal truncation and quadrature
 * 
 * @param Rb element dimension;
 * @param c distance to expansion centre;
 * @param rp distance from element to expansion centre;
 * @param order order of quadrature rule;
 * @param pmax maximum order of expansion;
 * @param smax maximum recursion depth in quadrature;
 * @param tol quadrature error tolerance;
 * @param pq on exit recommended expansion order;
 * @param s on exit recommended recursion depth.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_truncation_optimal(gdouble Rb, gdouble c,
					       gdouble rp,
					       gint order,
					       gint pmax, gint smax,
					       gdouble tol, gint *pq,
					       gint *s) ;


/**
 * @ingroup base
 *
 * @brief Curvatures on a triangular element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s coordinate on reference element;
 * @param t coordinate on reference element;
 * @param kg on exit Gaussian curvature on element in physical space at 
 * \f$(s,t)\f$;
 * @param km on exit mean curvature on element in physical space at
 * \f$(s,t)\f$.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_triangle_curvature(gdouble *xe, gint xstr, gint ne,
					       gdouble s, gdouble t,
					       gdouble *kg, gdouble *km) ;



/**
 * @ingroup util
 *
 * @brief Convert Cartesian to spherical coordinates
 * 
 * @param x0 centre of coordinate system;
 * @param x point;
 * @param r radius of \a x in spherical system centred on \a x0;
 * @param th azimuth of \a x in spherical system centred on \a x0;
 * @param ph elevation of \a x in spherical system centred on \a x0.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_cartesian_to_spherical(gdouble *x0,
						   gdouble *x,
						   gdouble *r,
						   gdouble *th,
						   gdouble *ph) ;

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on normalized associated Legendre functions
 *
 * Perform recursion on normalized associated Legendre functions with
 * input \f$P_{n-1}^{m}(\cos\theta)\f$, \f$0\leq m\leq n-1\f$, and
 * \f$P_{n}^{m}(\cos\theta)\f$, \f$0\leq m \leq n\f$, generating
 * equivalent outputs with \f$n\f$ incremented by one. Note that the
 * arrays of associated Legendre functions are switched internally to
 * ensure that the ordering remains correct after the recursion step. 
 *
 * @param Pnm1 pointer to array of normalized associated Legendre functions
 * for \f$n-1\f$;
 * @param Pn pointer to array of normalized associated Legendre functions 
 * for \f$n\f$;
 * @param n order of \a Pn;
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 *
 * @return 0 on success
 *
 */

gint qbx_legendre_recursion_array(gdouble **Pnm1,
						     gdouble **Pn,
						     gint n,
						     gdouble C,
						     gdouble S) ;

 /**
 *
 * @ingroup util
 *
 * @brief Initialize normalized associated Legendre functions
 *
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 * @param P0 on output \f$P_{0}^{0}(\cos\theta)\f$;
 * @param P10 on output \f$P_{1}^{0}(\cos\theta)\f$;
 * @param P11 on output \f$P_{1}^{1}(\cos\theta)\f$;
 *
 * @return 0 on success
 *
 */
gint qbx_legendre_init(gdouble C, gdouble S, 
					  gdouble *P0, gdouble *P10,
					  gdouble *P11) ;


/**
 * @ingroup
 *
 * @brief
 * 
 * @param 
 * 
 * @return 0 on success.
 * 
 **/
/**
 * @ingroup location
 *
 * @brief Locate nearest point on an element
 *
 * Locate the nearest point on an element using the iterative
 * algorithm of Li X, Wu Z, Pan F et al. A geometric strategy
 * algorithm for orthogonal projection onto a parametric
 * surface. https://dx.doi.org/10.1007/s11390-019-1967-z
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param xf field point;
 * @param sn on exit reference element coordinate of nearest point;
 * @param tn on exit reference element coordinate of nearest point;
 * @param p1 physical location of nearest point;
 * @param tol tolerance for iteration;
 * @param nimax maximum number of iterations;
 * @param kn curvature at nearest point.
 *
 * @return number of iterations
 **/

gint qbx_element_nearest_point_f(gfloat *xe, gint xstr,
						  gint ne,
						  gfloat *xf, 
						  gfloat *sn, gfloat *tn, 
						  gfloat *p1, gfloat tol,
						  gint nimax, gfloat *kn) ;

/**
 * @ingroup quadrature
 *
 * @brief Integration of Laplace potential on triangular element, with
 * field point on element ("self term")
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s0 reference element coordinate of evaluation point;
 * @param t0 reference element coordinate of evaluation point;
 * @param in if TRUE, generate expansion on the negative side of the 
 * element, as determined by surface normal;
 * @param q quadrature rule nodes and weights;
 * @param nq number of entries in \a q;
 * @param oq order of \a q (highest order polynomial integrated exactly);
 * @param Nmax maximum order of expansion;
 * @param dmax maximum recursin depth in adaptive quadrature;
 * @param tol error tolerance;
 * @param Is on exit integrated single layer potential for nodal shape 
 * functions;
 * @param istr stride in \a Is (ignored for now);
 * @param Id on exit integrated double layer potential for nodal shape 
 * functions;
 * @param dstr stride in \a Id (ignored for now);
 * @param work workspace.
 *
 * @return 0 on success
 *
 **/

gint qbx_triangle_laplace_self_quad_f(gfloat *xe,
						       gint xstr,
						       gint ne,
						       gfloat s0,
						       gfloat t0,
						       gboolean in,
						       gfloat *q,
						       gint nq, gint oq,
						       gint Nmax, gint dmax,
						       gfloat tol,
						       gfloat *Is, gint istr,
						       gfloat *Id, gint dstr,
						       gfloat *work) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace single layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of nodes in \a q;
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param C on exit contains coefficients of expansion;
 * @param str data stride in \a C
 *
 * @return 0 on success.
 *
 **/

gint qbx_expansion_make_laplace_sl_f(gfloat *xe,
						      gint xstr, gint ne,
						      gfloat *fe,
						      gint fstr, gint nf,
						      gfloat *q, gint nq,
						      gfloat *xc,
						      gfloat rc, gint N,
						      gfloat *C, gint str) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace double layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of nodes in \a q;
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param C on exit contains coefficients of expansion;
 * @param str data stride in \a C
 *
 * @return 0 on success.
 *
 **/

gint qbx_expansion_make_laplace_dl_f(gfloat *xe,
						      gint xstr, gint ne,
						      gfloat *fe,
						      gint fstr, gint nf,
						      gfloat *q, gint nq,
						      gfloat *xc,
						      gfloat rc, gint N,
						      gfloat *C, gint str) ;

/**
 * @ingroup laplace
 *
 * @brief Evaluate a Laplace expansion
 *
 * @param xc centre of expansion;
 * @param N order of expansion;
 * @param C expansion coefficients;
 * @param str stride/number of elements in function evaluation;
 * @param x evaluation point;
 * @param f on exit contains expansion evaluated at \a x for \a str elements;
 * @param ee on exit contains last term added to \a f, as error estimator.
 *
 * @return 0 on success.
 * 
 **/

gint qbx_expansion_eval_laplace_f(gfloat *xc, gint N,
						   gfloat *C, gint str,
						   gfloat *x, gfloat *f,
						   gfloat *ee) ;

/**
 * @ingroup laplace
 *
 * @brief Generate a QBX expansion for the Laplace double layer potential
 *
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param fe function values at element nodes;
 * @param fstr data stride in \a fe;
 * @param nf number of function values per element node;
 * @param q quadrature rule nodes and weights;
 * @param nq number of entries in \a q;
 * @param order order of \a q (highest order polynomial integrated exactly);
 * @param xc centre of expansion;
 * @param rc radius of expansion;
 * @param N order of expansion;
 * @param L expansion coefficients;
 * @param str stride of entries in \a L;
 * @param depth maximum recursion depth;
 * @param tol quadrature tolerance (used in terminating recursion);
 * @param w element dimension;
 * @param init if TRUE, zero expansion entries before integrating;
 * @param single if TRUE, generate expansion for single-layer potential, 
 * otherwise for double-layer.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_expansion_make_laplace_adaptive_f(gfloat *xe,
							    gint xstr, gint ne,
							    gfloat *fe,
							    gint fstr, gint nf,
							    gfloat *q,
							    gint nq, gint order,
							    gfloat *xc,
							    gfloat rc, gint N,
							    gfloat *L,
							    gint str,
							    gint depth,
							    gfloat tol,
							    gfloat w,
							    gboolean init,
							    gboolean single) ;
/**
 * @ingroup base
 *
 * @brief Shape function evaluations for three-dimensional elements
 * 
 * On entry \a L may not be NULL, but if \a dLds is NULL, first and
 * second derivatives are not evaluated. If \a dLdss is NULL, first
 * derivatives are evaluated, but not second.
 * 
 * @param ne number of nodes on element (currently 3 or 6);
 * @param s coordinate on element;
 * @param t coordinate on element;
 * @param L on exit shape function evaluated at each node;
 * @param dLds on exit \f$\partial L_{i}/\partial s\f$ at each node;
 * @param dLdt on exit \f$\partial L_{i}/\partial t\f$ at each node;
 * @param dLdss on exit \f$\partial^{2} L_{i}/\partial s^{2}\f$ at each node;
 * @param dLdst on exit \f$\partial^{2} L_{i}/\partial s\partial t\f$ 
 * at each node;
 * @param dLdtt on exit \f$\partial^{2} L_{i}/\partial t^{2}\f$ at each node;
 *
 * @return 0 on success.
 * 
 **/

gint qbx_element_shape_3d_f(gint ne, gfloat s, gfloat t,
					     gfloat *L,
					     gfloat *dLds, gfloat *dLdt,
					     gfloat *dLdss, gfloat *dLdst,
					     gfloat *dLdtt) ;

/**
 * @ingroup base
 *
 * @brief Interpolation of point on element using shape functions
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param L shape function from ::qbx_element_shape_3d_f(...);
 * @param dLds derivative of shape function;
 * @param dLdt derivative of shape function;
 * @param y on exit interpolated point on element;
 * @param n on exit normal at \a y;
 * @param J on exit Jacobian at \a y;
 * @param c reserved for future use (can be NULL).
 * 
 * @return 0 on success.
 *
 **/

gint qbx_element_point_interp_3d_f(gfloat *xe,
						    gint xstr, gint ne,
						    gfloat *L,
						    gfloat *dLds,
						    gfloat *dLdt,
						    gfloat *y,
						    gfloat *n,
						    gfloat *J,
						    gfloat *c) ;


/**
 * @ingroup base
 *
 * @brief Convenience function for direct evaluation of point position
 * on element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s coordinate on element;
 * @param t coordinate on element;
 * @param y on exit interpolated point on element;
 * @param n on exit normal at \a y;
 * @param J on exit Jacobian at \a y;
 * @param c reserved for future use (can be NULL).
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_element_point_3d_f(gfloat *xe, gint xstr, gint ne,
					     gfloat s, gfloat t,
					     gfloat *y, gfloat *n,
					     gfloat *J, gfloat *c) ;

/**
 * @ingroup base
 *
 * @brief Quadrature error estimator
 *
 * Quadrature error estimator from Siegel and Tornberg, A local target
 * specific quadrature by expansion method for evaluation of layer
 * potentials in 3D, https://doi.org/10.1016/j.jcp.2018.03.006
 * 
 * @param N order of expansion term;
 * @param h element dimension;
 * @param order order of quadrature rule;
 * @param r distance from expansion centre;
 * @param rp distance to closest point on element;
 * 
 * @return estimate of error in integration of \f$N\f$th expansion term.
 * 
 **/

gfloat qbx_quadrature_error_f(gint N, gfloat h, gint order,
						 gfloat r, gfloat rp) ;



/**
 * @ingroup base
 *
 * @brief Estimate surface area of element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param qrule nodes and weights of quadrature rule;
 * @param nq number of nodes in \a qrule.
 * 
 * @return estimate of area of element.
 * 
 **/

gfloat qbx_element_area_f(gfloat *xe, gint xstr, gint ne,
					     gfloat *qrule, gint nq) ;



/**
 * @ingroup base
 *
 * @brief Truncation error estimator for triangular element
 * 
 * Truncation error estimator from Siegel and Tornberg, A local target
 * specific quadrature by expansion method for evaluation of layer
 * potentials in 3D, https://doi.org/10.1016/j.jcp.2018.03.006
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param qrule quadrature rule used to estimate element area (does not 
 * need to be high order);
 * @param nq number of nodes in \a qrule;
 * @param N order of expansion;
 * @param rc distance from expansion centre;
 * @param depth recursion depth for subdivision of element;
 * @param ee on exit contains error estimators for single- and
 * double-layer potential evalution.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_triangle_truncation_error_f(gfloat *xe,
						      gint xstr, gint ne,
						      gfloat *qrule, gint nq,
						      gint N,
						      gfloat rc, gint depth,
						      gfloat *ee) ;



/**
 * @ingroup base
 *
 * @brief Estimate parameters for optimal truncation and quadrature
 * 
 * @param Rb element dimension;
 * @param c distance to expansion centre;
 * @param rp distance from element to expansion centre;
 * @param order order of quadrature rule;
 * @param pmax maximum order of expansion;
 * @param smax maximum recursion depth in quadrature;
 * @param tol quadrature error tolerance;
 * @param pq on exit recommended expansion order;
 * @param s on exit recommended recursion depth.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_truncation_optimal_f(gfloat Rb, gfloat c,
					       gfloat rp,
					       gint order,
					       gint pmax, gint smax,
					       gfloat tol, gint *pq,
					       gint *s) ;


/**
 * @ingroup base
 *
 * @brief Curvatures on a triangular element
 * 
 * @param xe element node coordinates;
 * @param xstr stride between \f$x\f$ coordinates of element nodes;
 * @param ne number of element nodes;
 * @param s coordinate on reference element;
 * @param t coordinate on reference element;
 * @param kg on exit Gaussian curvature on element in physical space at 
 * \f$(s,t)\f$;
 * @param km on exit mean curvature on element in physical space at
 * \f$(s,t)\f$.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_triangle_curvature_f(gfloat *xe, gint xstr, gint ne,
					       gfloat s, gfloat t,
					       gfloat *kg, gfloat *km) ;



/**
 * @ingroup util
 *
 * @brief Convert Cartesian to spherical coordinates
 * 
 * @param x0 centre of coordinate system;
 * @param x point;
 * @param r radius of \a x in spherical system centred on \a x0;
 * @param th azimuth of \a x in spherical system centred on \a x0;
 * @param ph elevation of \a x in spherical system centred on \a x0.
 * 
 * @return 0 on success.
 * 
 **/

gint qbx_cartesian_to_spherical_f(gfloat *x0,
						   gfloat *x,
						   gfloat *r,
						   gfloat *th,
						   gfloat *ph) ;

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on normalized associated Legendre functions
 *
 * Perform recursion on normalized associated Legendre functions with
 * input \f$P_{n-1}^{m}(\cos\theta)\f$, \f$0\leq m\leq n-1\f$, and
 * \f$P_{n}^{m}(\cos\theta)\f$, \f$0\leq m \leq n\f$, generating
 * equivalent outputs with \f$n\f$ incremented by one. Note that the
 * arrays of associated Legendre functions are switched internally to
 * ensure that the ordering remains correct after the recursion step. 
 *
 * @param Pnm1 pointer to array of normalized associated Legendre functions
 * for \f$n-1\f$;
 * @param Pn pointer to array of normalized associated Legendre functions 
 * for \f$n\f$;
 * @param n order of \a Pn;
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 *
 * @return 0 on success
 *
 */

gint qbx_legendre_recursion_array_f(gfloat **Pnm1,
						     gfloat **Pn,
						     gint n,
						     gfloat C,
						     gfloat S) ;

 /**
 *
 * @ingroup util
 *
 * @brief Initialize normalized associated Legendre functions
 *
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 * @param P0 on output \f$P_{0}^{0}(\cos\theta)\f$;
 * @param P10 on output \f$P_{1}^{0}(\cos\theta)\f$;
 * @param P11 on output \f$P_{1}^{1}(\cos\theta)\f$;
 *
 * @return 0 on success
 *
 */
gint qbx_legendre_init_f(gfloat C, gfloat S, 
					  gfloat *P0, gfloat *P10,
					  gfloat *P11) ;


/**
 * @ingroup
 *
 * @brief
 * 
 * @param 
 * 
 * @return 0 on success.
 * 
 **/
